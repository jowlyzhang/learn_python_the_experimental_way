"""An experiment to implement my own iterator class.

iterator VS generator:
=====================

Conceptually,

The name 'iterator' emphasize something that is ordered, can be looped, each
of its entry match the same pattern, theoretically, each of its entry can be
fed into the same function without breaking it.

For example, a table with students info, each row have one students' name, etc,
             a list with numbers,
             a dictionary for person's name and person's title,

These are the examples of iterable stuff. It's pretty clear that the emphasize
here is ordering stuff.

The name 'generator' emphasize a mechanism of spitting out something in a memory
efficient way. So the point of using a generator is to be memory efficient. It's
pretty intuitive to assume that generators should also be iterators, because
stuff generated by code are even more likely to have matching pattern in them
than manually made stuff. That also explains why the keyword 'in', 'for', 'next'
works flawlessly for generators.


iterable object VS iterator:
===========================
There is a builtin function 'iter' that takes an iterable object and give an iterator.
This description makes me thinking, what is the difference of those two and what is
the advantage of using it vs another. So I did following experiment:
    >> a = [1, 2, 3,4]
    >> b = iter(a)
    >> type(a) # list
    >> type(b) # listiterator
    >> for i in a:
    >>     print a
    >> next(a) # TypeError
    >> for i in b:
    >>     print i
    >> next(b) # StopIteration

    Do similar experiment with a dictionary, results are similar and it's also fun.
    The main difference, instead of a 'listiterator', it's a 'dictionary-keyiterator'.
    To sum up my observations:

    Common: 'for in' would work for both iterable objects and iterators.

    Diff: 'next' only work for iterators, not iterable objects.
          iterators would come to an end, iterable objects are just objects storing
          iterable stuff.

    Advantage: I dont know for now.

Summary:
========

    1. generators are also iterators (understand the difference between
       generators and functions that return generators)

    2. iterators protocol including:
           a) an '__iter__' method that returns itself
           b) an 'next' method that returns next value when called by next
              in python 3.x, it's '__next__' method instead.

    3. and they both work on an iterable object, in the below example, it's 'numbers'.
"""

class myGene(object):
    """This is my implementation of a generator
    """

    def __init__(self, numbers):
        self.numbers = numbers
        self.length = len(numbers)
        self.i = 0
        self.generator = self.init_generator()

    def next(self):
        """next(b) would become b.next()
        """
        return next(self.generator)

    def init_generator(self):
        while True:
            if self.i >= self.length:
                raise StopIteration
            yield self.numbers[self.i]
            self.i += 1

    def __iter__(self):
        return self


class myIter(object):
    """This is my implementation of an iterator.
    """

    def __init__(self, numbers):
        self.numbers = numbers
        self.length = len(numbers)
        self.i = 0

    def next(self):
        if self.i < self.length:
            i = self.i
            self.i += 1
            return self.numbers[i]
        else:
            raise StopIteration

    def __iter__(self):
        return self

